<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>タイヤ積載シミュレーション</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 15px; 
            display: flex;
            gap: 15px; 
            justify-content: flex-start; 
            align-items: flex-start;
            background-color: #f0f2f5; 
            min-height: 100vh; 
            position: relative;
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none;    
            -ms-user-select: none;     
            overscroll-behavior-y: none; /* プル・トゥ・リフレッシュを無効化 */
        }
        .controls {
            padding: 8px; 
            border: none;
            border-radius: 10px; 
            background-color: #ffffff;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1); 
            width: 250px; 
            z-index: 100;
            min-width: 120px; /* スマホで狭くても最低幅確保 */
            overflow-y: auto; /* 高さ超過時はスクロール */
            max-height: 100vh; /* 画面高さ制限 */
            overscroll-behavior-y: auto; /* パネル内はスクロール可能 */
        }
        .controls h2, .controls h3 { display: none; }
        .controls label, .controls select, .controls button, .controls input[type="number"], .controls input[type="text"] {
            display: block;
            margin-bottom: 3px; 
            width: 100%;
            box-sizing: border-box;
            font-size: 13px; /* 狭い画面で読みやすく */
            white-space: nowrap; /* テキスト折り返し防止 */
            overflow: hidden; /* 長いテキストは隠す */
            text-overflow: ellipsis; /* 長いテキストは...表示 */
        }
        .controls select, .controls input[type="number"], .controls input[type="text"] {
            padding: 5px 7px; 
            border: 1px solid #ccc;
            border-radius: 4px; 
            font-size: 13px; 
            background-color: #f9f9f9;
            user-select: auto; 
        }
        .controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 10px; 
            border-radius: 5px; 
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 3px 0 #0056b3; 
            margin-top: 3px;
            font-size: 13px; /* ボタンテキスト調整 */
        }
        .controls button:hover { background-color: #0056b3; }
        .controls button:active {
            box-shadow: 0 1px 0 #0056b3;
            transform: translateY(2px); 
        }
        #reset-btn {
            background-color: #dc3545; 
            box-shadow: 0 3px 0 #bd2130;
            margin-top: 10px; 
        }
        .history-controls button {
            display: inline-block;
            width: calc(50% - 5px); 
            box-shadow: 0 3px 0 #5a6268;
            background-color: #6c757d;
            padding: 7px; 
            font-size: 12px; 
        }
        #info-panel, #tire-data-panel {
            margin-top: 5px; 
            padding-top: 5px; 
            border-top: 1px solid #ddd;
        }
        #info-panel p, #tire-data-panel p {
            margin: 2px 0; 
            font-size: 13px; 
            color: #555;
            user-select: none; 
            white-space: nowrap; /* 折り返し防止 */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .data-value {
            white-space: normal; /* 折り返し許可 */
            word-wrap: break-word; /* 単語折り返し */
        }
        #tire-data-panel {
            margin-top: 10px; 
            padding: 6px 0;
            border-top: none; /* 上部線削除 */
        }
        #reset-item-btn {
            box-shadow: 0 3px 0 #d39e00;
        }
        .section-divider {
            margin: 3px 0; 
        }
        .truck-container {
            display: flex; 
            flex-direction: column;
            align-items: flex-start;
            transform-origin: top left; 
            flex-shrink: 0;
            transition: transform 0.3s ease; /* トグル時のアニメーション */
        }
        #loading-bay {
            border: 2px solid #333;
            background-color: #e0e0e0;
            position: relative; 
            overflow: visible; 
            flex-shrink: 0; 
        }
        .guide-line {
            position: absolute;
            left: 0;
            width: 100%;
            border-top: 1px dashed #aaa;
            z-index: 1; 
        }
        .tire {
            position: absolute; 
            border-radius: 50%; 
            cursor: grab; 
            box-sizing: border-box; 
            touch-action: none; 
            display: flex; 
            justify-content: center;
            align-items: center;
            font-weight: bold;
            z-index: 10; 
            user-select: none; 
            background-color: #333; 
            border: 4px solid #000; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); 
        }
        .tire::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            width: 50%;
            height: 50%;
            background-color: #e0e0e0; 
            z-index: 11;
        }
        .tire-label {
            position: relative;
            z-index: 12; 
            color: #fff; 
            text-shadow: 0 0 5px #000;
            line-height: 1;
        }
        .tire-product-code {
            position: absolute;
            top: 5%; 
            color: white; 
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            z-index: 13;
            line-height: 1;
        }
        .tire:not([data-in-bay="true"]) {
             background-color: #666; 
             border-color: #444;
             opacity: 0.8;
        }
        .custom-context-menu {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            padding: 5px 0;
            z-index: 1000;
            min-width: 150px;
            user-select: none;
        }
        .custom-context-menu button {
            display: block;
            width: 100%;
            padding: 8px 15px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-weight: normal; 
            box-shadow: none;
            transition: background-color 0.1s;
        }
        .replication-options label, .replication-options input, .replication-options select {
            padding: 3px 5px !important; 
            font-size: 12px !important;
        }
        #startup-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        #startup-dialog-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        /* レスポンシブ調整: 狭い画面で荷台幅縮小 (例: 画面幅600px以下で適用) */
        @media screen and (max-width: 600px) {
            .truck-container {
                width: 190px; /* 最低180-190px確保、2:1比率目安で調整 */
            }
            #loading-bay {
                width: 190px; /* 荷台幅縮小 */
            }
            .controls {
                width: 95px; /* パネル幅も比例縮小 (2:1目安) */
            }
            /* 縦も比例縮小: JSでBAY_LENGTH_PXを調整するが、CSSで補助 */
        }
        /* トグルボタンスタイル */
        #toggle-scale-btn {
            background-color: #28a745;
            box-shadow: 0 3px 0 #1e7e34;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="startup-dialog">
        <div id="startup-dialog-content">
            <h2>荷台長を入力</h2>
            <input type="number" id="bay-length-input" placeholder="荷台長(mm)" min="5000" max="15000" step="100">
            <button id="set-bay-btn">設定</button>
        </div>
    </div>

    <div class="truck-container">
        <div id="loading-bay"></div>
    </div>

    <div class="controls" id="controls-panel">
        <h2>操作履歴</h2>
        <div class="history-controls">
            <button id="undo-btn" disabled>戻る</button>
            <button id="redo-btn" disabled>進む</button>
        </div>
        
        <div class="section-divider"></div>

        <div id="tire-data-panel">
            <label for="product-code-input">品番:</label>
            <input type="text" id="product-code-input" placeholder="例: 0004">
            <button id="search-code-btn" style="margin-top: -4px; margin-bottom: 3px;">検索</button>

            <p id="data-size" class="data-value"></p>
            <p>直径: <span id="data-diameter-csv" class="data-value"></span></p>
            <p>幅: <span id="data-width" class="data-value"></span></p>
            <p>パレット: <span id="data-pallet" class="data-value"></span></p>
            <p>特記: <span id="data-note" class="data-value"></span></p>
            <button id="reset-item-btn">リセット</button>
        </div>

        <div class="section-divider"></div>

        <h2>タイヤ作成</h2>
        <label for="tire-diameter">直径:</label>
        <select id="tire-diameter">
            <option value="750">750</option>
            <option value="800">800</option>
            <option value="850">850</option>
            <option value="900" selected>900</option>
            <option value="950">950</option>
            <option value="1000">1000</option>
            <option value="1050">1050</option>
            <option value="1100">1100</option>
            <option value="1150">1150</option>
            <option value="1200">1200</option>
        </select>
        <button id="create-tire-btn">作成</button>

        <div id="info-panel">
            <h3>積載情報</h3>
            <p>荷台長: <span id="bay-length-info"></span></p>
            <p>総数: <span id="tire-count-info">0</span></p>
            <p>積載長: <span id="distance-info"></span></p>
        </div>
        
        <button id="reset-btn">リセット</button>
        <button id="toggle-scale-btn">全体表示</button>
    </div>

    <div class="custom-context-menu" id="tire-context-menu" style="display: none;">
        <button id="menu-delete-btn">消去</button>
        <div class="menu-divider"></div>
        <div class="replication-options">
            <label>連続複製</label>
            <div>
                <label for="replication-count" style="display: inline;">個数:</label>
                <select id="replication-count" style="width: 60px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10" selected>10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                </select>
            </div>
            <div>
                <label for="replication-spacing" style="display: inline;">間隔:</label>
                <select id="replication-spacing" style="width: 60px;">
                    <option value="0">0</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="150">150</option>
                    <option value="200">200</option>
                    <option value="250">250</option>
                </select>
            </div>
            <button id="menu-replicate-btn">実行</button>
        </div>
    </div>

    <script>
        // ------------------ CSVデータ貼り付けエリア ------------------
        const CSV_DATA_STRING = `code,size,diameter,width,pallet,note
0001,215/70R17.5,738,215,10,なし
0002,225/80R17.5,785,225,10,なし
0003,245/70R19.5,801,245,8,なし
0004,275/70R22.5,899,275,8,特注品
0005,295/80R22.5,930,295,6,要在庫確認
0006,315/80R22.5,960,315,6,なし
0007,385/65R22.5,1050,385,4,扁平タイヤ注意
0008,425/65R22.5,1100,425,4,なし
0009,12.00R24,1150,300,4,重量注意
0010,14.00R24,1200,350,2,重量注意`;

        // ------------------ CSV解析ロジック ------------------
        let TIRE_DATA = [];
        function parseCsvData(csvString) {
            const lines = csvString.trim().split('\n');
            if (lines.length <= 1) return [];

            const rawHeaders = lines[0].split(',').map(h => h.trim().toLowerCase());
            const requiredHeaders = {
                'code': 'code', 'size': 'size', 'diameter': 'diameter', 
                'width': 'width', 'pallet': 'pallet', 'note': 'note'
            };
            const headerMapping = {};
            for(const required in requiredHeaders) {
                const index = rawHeaders.indexOf(required);
                if (index !== -1) {
                    headerMapping[index] = requiredHeaders[required];
                }
            }

            const dataArray = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                const item = {};
                let isValid = true;
                
                for (const index in headerMapping) {
                    const key = headerMapping[index];
                    let value = values[index];
                    
                    if (key === 'diameter' || key === 'width' || key === 'pallet') {
                        value = parseInt(value, 10);
                        if (isNaN(value) && (key === 'diameter' || key === 'width')) {
                            console.warn(`CSV Parse Error: Line ${i+1} has non-numeric value for ${key}. Skipping.`);
                            isValid = false;
                            break;
                        }
                    }
                    item[key] = value;
                }
                
                if (isValid && item.code) {
                     item.code = String(item.code).padStart(4, '0');
                     dataArray.push(item);
                }
            }
            return dataArray;
        }

        TIRE_DATA = parseCsvData(CSV_DATA_STRING);
        
        // ------------------ 荷台初期化ロジック ------------------
        let BAY_LENGTH_MM = 0; 
        let BAY_WIDTH_MM = 2400;   
        let SCALE_FACTOR = 10;     
        let BAY_WIDTH_PX = BAY_WIDTH_MM / SCALE_FACTOR; 
        let BAY_LENGTH_PX = 0; 
        
        let tireCounter = 0; 
        let history = [];
        let historyIndex = -1;
        
        let currentProductData = null; 
        let isScaledDown = false; // トグル状態

        function initializeBay(lengthMM) {
            const loadingBay = document.getElementById('loading-bay');
            const bayLengthInfo = document.getElementById('bay-length-info'); 
            const startupDialog = document.getElementById('startup-dialog');
            
            BAY_LENGTH_MM = lengthMM;
            BAY_LENGTH_PX = BAY_LENGTH_MM / SCALE_FACTOR;

            loadingBay.style.height = `${BAY_LENGTH_PX}px`;
            loadingBay.style.width = `${BAY_WIDTH_PX}px`;
            
            bayLengthInfo.textContent = `${BAY_LENGTH_MM}`; 
            
            document.querySelectorAll('.tire').forEach(tire => tire.remove());
            tireCounter = 0;
            history = []; 
            historyIndex = -1;
            
            drawGuides(); 
            saveState(); 
            updateTireCount();
            updateDistanceInfo();
            
            startupDialog.style.display = 'none'; 
            adjustResponsive(); 
        }
        
        function resetSimulation() {
            BAY_LENGTH_MM = 0;
            BAY_LENGTH_PX = 0;
            tireCounter = 0;
            history = [];
            historyIndex = -1;
            
            document.querySelectorAll('.tire').forEach(tire => tire.remove());
            document.getElementById('loading-bay').querySelectorAll('.guide-line').forEach(line => line.remove());
            document.getElementById('loading-bay').style.height = '0px';
            
            document.getElementById('bay-length-info').textContent = '';
            
            resetProductInfo(); 
            updateTireCount();
            updateDistanceInfo();
            updateHistoryButtons();
            
            document.getElementById('startup-dialog').style.display = 'flex';
            document.querySelector('.truck-container').style.transform = 'scale(1)'; 
            isScaledDown = false;
            updateToggleButtonText();
        }
        
        // ------------------ 初期設定とDOM要素の取得 ------------------
        const createTireBtn = document.getElementById('create-tire-btn');
        const tireDiameterSelect = document.getElementById('tire-diameter');
        const controlsPanel = document.getElementById('controls-panel');
        const resetBtn = document.getElementById('reset-btn');
        const productCodeInput = document.getElementById('product-code-input');
        const searchCodeBtn = document.getElementById('search-code-btn');
        const resetItemBtn = document.getElementById('reset-item-btn');
        const dataSizeSpan = document.getElementById('data-size');
        const dataDiameterCsvSpan = document.getElementById('data-diameter-csv');
        const dataWidthSpan = document.getElementById('data-width');
        const dataPalletSpan = document.getElementById('data-pallet');
        const dataNoteSpan = document.getElementById('data-note');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const contextMenu = document.getElementById('tire-context-menu');
        const menuDeleteBtn = document.getElementById('menu-delete-btn');
        const menuReplicateBtn = document.getElementById('menu-replicate-btn');
        const replicationCountSelect = document.getElementById('replication-count');
        const replicationSpacingSelect = document.getElementById('replication-spacing');
        const toggleScaleBtn = document.getElementById('toggle-scale-btn');
        const setBayBtn = document.getElementById('set-bay-btn');
        const bayLengthInput = document.getElementById('bay-length-input');
        let activeTire = null;

        // トグルイベント
        toggleScaleBtn.addEventListener('click', toggleScale);

        // 荷台設定イベント
        setBayBtn.addEventListener('click', () => {
            const lengthMM = parseInt(bayLengthInput.value, 10);
            if (isNaN(lengthMM) || lengthMM < 5000 || lengthMM > 15000) {
                alert('有効な荷台長 (5000-15000mm) を入力してください。');
                return;
            }
            initializeBay(lengthMM);
        });

        // ------------------ 品番情報検索・リセットロジック ------------------
        function searchProductCode() {
            const rawCode = productCodeInput.value.trim();
            const paddedCode = rawCode.padStart(4, '0');
            
            if (!rawCode) {
                alert("品番を入力してください。");
                resetProductInfo();
                return;
            }
            
            const data = TIRE_DATA.find(item => item.code === paddedCode);
            
            if (data) {
                currentProductData = data;
                productCodeInput.value = paddedCode; 
                
                dataSizeSpan.textContent = data.size;
                dataDiameterCsvSpan.textContent = `${data.diameter}`;
                dataWidthSpan.textContent = `${data.width}`;
                dataPalletSpan.textContent = data.pallet;
                dataNoteSpan.textContent = data.note;
                
            } else {
                alert(`品番「${rawCode}」のデータは見つかりませんでした。`);
                resetProductInfo();
            }
        }
        
        function resetProductInfo() {
            currentProductData = null;
            productCodeInput.value = '';
            
            dataSizeSpan.textContent = '';
            dataDiameterCsvSpan.textContent = '';
            dataWidthSpan.textContent = '';
            dataPalletSpan.textContent = '';
            dataNoteSpan.textContent = '';
        }

        function loadProductInfoFromTire(tire) {
            const code = tire.dataset.productCode;
            if (code) {
                productCodeInput.value = code;
                searchProductCode();
            } else {
                resetProductInfo();
            }
        }

        // ------------------ イベントリスナー ------------------
        searchCodeBtn.addEventListener('click', searchProductCode);
        productCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                searchProductCode();
            }
        });
        
        productCodeInput.addEventListener('focus', resetProductInfo);

        resetItemBtn.addEventListener('click', resetProductInfo);
        tireDiameterSelect.addEventListener('change', () => {
            if (currentProductData) {
                resetProductInfo(); 
            }
        });
        createTireBtn.addEventListener('click', () => {
            if (BAY_LENGTH_MM === 0) {
                alert('先に荷台を選択してください。');
                return;
            }
            createTire(null, null, null, currentProductData);
            saveState(); 
        });
        resetBtn.addEventListener('click', () => {
            if (confirm('リセットしますか？')) {
                resetSimulation();
            }
        });

        undoBtn.addEventListener('click', () => loadState(historyIndex - 1));
        redoBtn.addEventListener('click', () => loadState(historyIndex + 1));

        // ------------------ 描画ロジック ------------------
        function createTire(initialX = null, initialY = null, diameterMM = null, productData = null) {
            const selectedDiameterMM = parseFloat(tireDiameterSelect.value);
            diameterMM = diameterMM || (productData ? productData.diameter : selectedDiameterMM);
            
            const diameterPX = diameterMM / SCALE_FACTOR; 
            const radiusPX = diameterPX / 2;

            if (diameterPX > BAY_WIDTH_PX) {
                if (initialX !== null) { 
                    console.warn(`Tire diameter (${diameterMM}mm) exceeds bay width.`);
                } else {
                    alert(`選択されたタイヤ (${diameterMM}) は荷台の幅 (${BAY_WIDTH_MM}) を超えているため配置できません。`);
                    return null;
                }
            }
            
            tireCounter++;

            const tire = document.createElement('div');
            tire.classList.add('tire');
            tire.id = `tire-${tireCounter}`; 

            tire.style.width = `${diameterPX}px`;
            tire.style.height = `${diameterPX}px`;
            
            const label = document.createElement('span');
            label.classList.add('tire-label');
            label.textContent = `${diameterMM}`; 
            tire.appendChild(label);
            
            const finalProductData = productData || (currentProductData && currentProductData.diameter === diameterMM ? currentProductData : null);

            if (finalProductData && finalProductData.code) {
                const codeSpan = document.createElement('span');
                codeSpan.classList.add('tire-product-code');
                codeSpan.textContent = finalProductData.code;
                tire.appendChild(codeSpan);
            }
            
            adjustTireLabelSizes(tire, diameterPX);
            
            tire.dataset.diameterPx = diameterPX;
            tire.dataset.radiusPx = radiusPX;
            tire.dataset.diameterMm = diameterMM;
            
            if (finalProductData) {
                tire.dataset.productCode = finalProductData.code;
            }
            
            const loadingBay = document.getElementById('loading-bay');
            
            if (initialX !== null && initialY !== null) {
                const clampedPos = clampToBay(initialX, initialY, diameterPX);
                
                tire.style.position = 'absolute';
                tire.style.left = `${clampedPos.x}px`;
                tire.style.top = `${clampedPos.y}px`;
                tire.dataset.inBay = "true";
                
                loadingBay.appendChild(tire);
            } else {
                const padding = 10;
                let newX = BAY_WIDTH_PX - diameterPX - padding;
                let newY = BAY_LENGTH_PX - diameterPX - padding;
                
                const clampedPos = clampToBay(newX, newY, diameterPX);
                
                tire.style.position = 'absolute';
                tire.style.left = `${clampedPos.x}px`;
                tire.style.top = `${clampedPos.y}px`;
                tire.dataset.inBay = "true";
                
                loadingBay.appendChild(tire);
            }
            
            makeDraggable(tire);
            setupContextMenu(tire);
            
            updateTireCount();
            updateDistanceInfo();
            return tire;
        }
        
        function adjustTireLabelSizes(tire, diameterPX) {
            const label = tire.querySelector('.tire-label'); 
            const codeSpan = tire.querySelector('.tire-product-code'); 
            
            const labelSize = Math.max(12, diameterPX * 0.15); 
            if (label) {
                label.style.fontSize = `${labelSize}px`;
            }
            
            const codeSize = Math.max(10, diameterPX * 0.12); 
            if (codeSpan) {
                codeSpan.style.fontSize = `${codeSize}px`;
            }
        }
        
        // ------------------ 情報更新ロジック ------------------
        function updateTireCount() { 
            const count = document.querySelectorAll('.tire').length;
            document.getElementById('tire-count-info').textContent = count;
        }
        function updateDistanceInfo() { 
            const loadingBay = document.getElementById('loading-bay'); 
            const tires = loadingBay.querySelectorAll('.tire[data-in-bay="true"]');
            let maxBottomY_PX = 0; 
            
            tires.forEach(tire => {
                const topY = parseFloat(tire.style.top);
                const diameter = parseFloat(tire.dataset.diameterPx);
                const bottomY = topY + diameter;
                
                if (bottomY > maxBottomY_PX) {
                    maxBottomY_PX = bottomY;
                }
            });

            if (tires.length === 0) {
                document.getElementById('distance-info').textContent = ''; 
                return;
            }

            const maxBottomY_MM = Math.round(maxBottomY_PX * SCALE_FACTOR);
            document.getElementById('distance-info').textContent = `${maxBottomY_MM}`;
        }
        
        // ------------------ コンテキストメニュー操作ロジック ------------------
        function deleteTire(tire) {
            if (tire) {
                tire.remove();
                hideContextMenu();
                updateTireCount();
                updateDistanceInfo();
                saveState();
            }
        }
        
        function replicateTire(baseTire) {
            if (!baseTire || baseTire.dataset.inBay !== "true") {
                alert("荷台内のタイヤのみ複製可能です。");
                hideContextMenu();
                return;
            }

            const count = parseInt(replicationCountSelect.value, 10);
            const spacingMM = parseInt(replicationSpacingSelect.value, 10);
            const spacingPX = spacingMM / SCALE_FACTOR;

            const diameterPX = parseFloat(baseTire.dataset.diameterPx);
            const startX = parseFloat(baseTire.style.left);
            let currentY = parseFloat(baseTire.style.top);
            
            let productData = null;
            if (baseTire.dataset.productCode) {
                 const code = baseTire.dataset.productCode;
                 productData = TIRE_DATA.find(item => item.code === code) || null;
            }

            for (let i = 0; i < count; i++) {
                const newY = currentY + diameterPX + spacingPX;
                
                if (newY + diameterPX > BAY_LENGTH_PX) {
                    if (i === 0) {
                        alert("複製数が多すぎるため、荷台からはみ出します。");
                    } else {
                        alert(`${i+1}個以降は荷台からはみ出すため、複製を中断しました。`);
                    }
                    break;
                }

                const newTire = createTire(startX, newY, parseFloat(baseTire.dataset.diameterMm), productData); 
                
                if (newTire) {
                    const { x: finalX, y: finalY } = resolveCollisions(startX, newY, diameterPX, newTire);
                    newTire.style.left = `${finalX}px`;
                    newTire.style.top = `${finalY}px`;
                    currentY = finalY; 
                } else {
                    break; 
                }
            }

            hideContextMenu();
            saveState();
            updateTireCount();
            updateDistanceInfo();
        }
        
        function initializeContextMenuListeners() {
            menuDeleteBtn.onclick = () => {
                deleteTire(activeTire);
            };
            
            menuReplicateBtn.onclick = () => {
                replicateTire(activeTire);
            };

            replicationCountSelect.addEventListener('click', (e) => {
                e.stopPropagation(); 
            });
            replicationSpacingSelect.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            contextMenu.querySelectorAll('.replication-options label').forEach(label => {
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
        }
        
        function setupContextMenu(element) {
            element.addEventListener('contextmenu', (e) => showContextMenu(e, element));
        }

        function showContextMenu(e, element) {
            e.preventDefault(); 
            
            activeTire = element; 
            
            contextMenu.style.display = 'block';
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            
            contextMenu.style.left = `${clientX + window.scrollX + 5}px`;
            contextMenu.style.top = `${clientY + window.scrollY + 5}px`;

            document.addEventListener('click', hideContextMenu, { once: true });
        }
        
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            activeTire = null;
        }

        // ------------------ ドラッグロジック ------------------
        function makeDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;
            let initialPosition = {};
            let loadingBay = document.getElementById('loading-bay');
            
            let dragStarted = false; 
            let startClientX, startClientY;
            
            let lastTapTime = 0; 
            const DOUBLE_TAP_THRESHOLD = 300;

            function getBayRect() {
                const rect = loadingBay.getBoundingClientRect();
                const truckContainer = document.querySelector('.truck-container');
                const scale = parseFloat(truckContainer.style.transform.match(/scale\(([^)]+)\)/)?.[1] || 1);
                return {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width / scale,  // 内部ロジック用にスケール前サイズに戻す
                    height: rect.height / scale,
                    scale: scale
                };
            }

            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDragTouch, { passive: false }); 

            function startDrag(e) {
                if (e.button === 2) { 
                    return;
                }
                
                if (isDragging) return; 

                hideContextMenu(); 
                
                startClientX = e.clientX;
                startClientY = e.clientY;
                
                isDragging = true;
                dragStarted = false; 

                element.dataset.isDragging = 'true'; 
                element.style.cursor = 'grabbing';
                
                const clientX = e.clientX;
                const clientY = e.clientY;
                
                const bayRect = getBayRect();
                const elementRect = element.getBoundingClientRect();
                
                initialPosition.left = element.style.left;
                initialPosition.top = element.style.top;
                initialPosition.parent = element.parentNode.id;

                // スケール補正: offsetをスケール分で調整
                offsetX = (clientX - elementRect.left) / bayRect.scale;
                offsetY = (clientY - elementRect.top) / bayRect.scale;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }
            
            function startDragTouch(e) {
                if (isDragging) return;
                
                hideContextMenu(); 
                
                const clientX = e.touches[0].clientX;
                const clientY = e.touches[0].clientY;

                startClientX = clientX;
                startClientY = clientY;
                
                isDragging = true;
                dragStarted = false; 

                element.dataset.isDragging = 'true'; 
                element.style.cursor = 'grabbing';
                
                const bayRect = getBayRect();
                const elementRect = element.getBoundingClientRect();
                
                initialPosition.left = element.style.left;
                initialPosition.top = element.style.top;
                initialPosition.parent = element.parentNode.id;

                // スケール補正: offsetをスケール分で調整
                offsetX = (clientX - elementRect.left) / bayRect.scale;
                offsetY = (clientY - elementRect.top) / bayRect.scale;

                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('touchend', stopDrag);
            }

            function drag(e) {
                if (!isDragging) return;
                
                dragStarted = true; 

                // 荷台外のスクロールを許可
                const bayRect = getBayRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const isOutsideBay = clientX < bayRect.left || clientX > bayRect.left + bayRect.width * bayRect.scale ||
                                     clientY < bayRect.top || clientY > bayRect.top + bayRect.height * bayRect.scale;
                if (isOutsideBay) {
                    return; // 荷台外ならデフォルト動作（スクロール）を許可
                }
                if (e.cancelable) {
                    e.preventDefault(); // 荷台内ではデフォルト動作をキャンセル
                }
                
                const bayRect = getBayRect();
                
                // スケール補正: 新位置をスケール前座標で計算
                let newBodyX = (clientX + window.scrollX - offsetX * bayRect.scale - bayRect.left) / bayRect.scale + bayRect.left / bayRect.scale;
                let newBodyY = (clientY + window.scrollY - offsetY * bayRect.scale - bayRect.top) / bayRect.scale + bayRect.top / bayRect.scale;
                
                const bayAbsLeft = bayRect.left;
                const bayAbsTop = bayRect.top;
                const bayAbsRight = bayAbsLeft + bayRect.width * bayRect.scale;
                const bayAbsBottom = bayAbsTop + bayRect.height * bayRect.scale;
                
                const diameter = parseFloat(element.dataset.diameterPx);
                const scaledDiameter = diameter * bayRect.scale;

                const tireCenterAbsX = clientX - offsetX * bayRect.scale + scaledDiameter / 2;
                const tireCenterAbsY = clientY - offsetY * bayRect.scale + scaledDiameter / 2;
                
                const inBayArea = tireCenterAbsX > bayAbsLeft && tireCenterAbsX < bayAbsRight &&
                                  tireCenterAbsY > bayAbsTop && tireCenterAbsY < bayAbsBottom;

                element.dataset.inBay = inBayArea ? "true" : "false";

                if (inBayArea) {
                    let relX = (clientX - bayAbsLeft - offsetX * bayRect.scale) / bayRect.scale;
                    let relY = (clientY - bayAbsTop - offsetY * bayRect.scale) / bayRect.scale;

                    if (element.parentNode !== loadingBay) {
                        if(element.parentNode === document.body) document.body.removeChild(element);
                        loadingBay.appendChild(element);
                        element.style.position = 'absolute'; 
                    }
                    
                    const { x: finalX, y: finalY } = resolveCollisions(relX, relY, diameter, element);
                    
                    const clampedPos = clampToBay(finalX, finalY, diameter);
                    element.style.left = `${clampedPos.x}px`;
                    element.style.top = `${clampedPos.y}px`;

                } else {
                    if (element.parentNode !== document.body) {
                        if (element.parentNode === loadingBay) loadingBay.removeChild(element);
                        document.body.appendChild(element);
                        element.style.position = 'absolute'; 
                    }
                    
                    element.style.left = `${newBodyX * bayRect.scale}px`;
                    element.style.top = `${newBodyY * bayRect.scale}px`;
                }
                
                updateDistanceInfo();
            }

            function stopDrag(e) {
                if (!isDragging) return;
                
                const isTouchEvent = e.type.startsWith('touch');
                const endClientX = isTouchEvent ? e.changedTouches[0].clientX : e.clientX;
                const endClientY = isTouchEvent ? e.changedTouches[0].clientY : e.clientY;
                
                const movedDistance = Math.sqrt(
                    Math.pow(endClientX - startClientX, 2) + 
                    Math.pow(endClientY - startClientY, 2)
                );
                
                const isTap = movedDistance < 5 && !dragStarted;
                
                if (isTouchEvent && isTap) {
                    const currentTime = new Date().getTime();
                    if (currentTime - lastTapTime < DOUBLE_TAP_THRESHOLD) {
                        showContextMenu(e, element);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = currentTime;
                        if (element.dataset.inBay === "true") {
                            loadProductInfoFromTire(element);
                        }
                    }
                } else if (!isTouchEvent && isTap) {
                    if (element.dataset.inBay === "true") {
                        loadProductInfoFromTire(element);
                    }
                }

                isDragging = false;
                dragStarted = false; 
                element.dataset.isDragging = 'false'; 
                element.style.cursor = 'grab';

                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', stopDrag);
                
                if (element.style.left !== initialPosition.left || 
                    element.style.top !== initialPosition.top ||
                    (element.parentNode.id === 'loading-bay' ? initialPosition.parent !== 'loading-bay' : initialPosition.parent === 'loading-bay')) {
                    saveState();
                }

                updateDistanceInfo();
            }
        }

        // ------------------ 履歴ロジック ------------------
        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function saveState(isInit = false) {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            const state = {
                tires: [],
                bayLength: BAY_LENGTH_MM,
                tireCounter: tireCounter 
            };
            
            document.querySelectorAll('.tire').forEach(tire => {
                const inBay = tire.dataset.inBay === "true";
                
                state.tires.push({
                    id: tire.id,
                    x: parseFloat(tire.style.left),
                    y: parseFloat(tire.style.top),
                    diameterMM: parseFloat(tire.dataset.diameterMm),
                    productCode: tire.dataset.productCode || '',
                    inBay: inBay
                });
            });

            history.push(JSON.stringify(state));
            historyIndex++;
            updateHistoryButtons();
        }

        function loadState(index) {
            if (index < 0 || index >= history.length) return;
            
            historyIndex = index;
            const stateString = history[historyIndex];
            const state = JSON.parse(stateString);
            
            document.querySelectorAll('.tire').forEach(tire => tire.remove());
            
            let maxTireId = 0; 
            
            const loadingBay = document.getElementById('loading-bay');
            
            state.tires.forEach(tireData => {
                const idNum = parseInt(tireData.id.split('-')[1], 10);
                if (idNum > maxTireId) maxTireId = idNum;
                
                const productData = TIRE_DATA.find(item => item.code === tireData.productCode) || null;
                
                const newTire = createTire(tireData.x, tireData.y, tireData.diameterMM, productData);
                
                if (newTire) {
                    newTire.id = tireData.id; 

                    if (tireData.inBay) {
                        newTire.dataset.inBay = "true";
                        loadingBay.appendChild(newTire);
                    } else {
                        newTire.dataset.inBay = "false";
                        document.body.appendChild(newTire);
                    }
                }
            });
            
            tireCounter = maxTireId;

            updateTireCount();
            updateDistanceInfo();
            updateHistoryButtons();
        }

        // ------------------ その他ロジック ------------------
        function drawGuides() { 
            const loadingBay = document.getElementById('loading-bay'); 
            loadingBay.querySelectorAll('.guide-line').forEach(line => line.remove());
            const SNAP_GRID_MM = 1000;
            for (let mm = 0; mm <= BAY_LENGTH_MM; mm += SNAP_GRID_MM) {
                const px = mm / SCALE_FACTOR;
                if (mm > 0 && mm < BAY_LENGTH_MM) {
                    const line = document.createElement('div');
                    line.classList.add('guide-line');
                    line.style.top = `${px}px`;
                    loadingBay.appendChild(line);
                }
            }
        }

        function resolveCollisions(relX, relY, diameter, currentTire) {
            const loadingBay = document.getElementById('loading-bay'); 
            const radius = diameter / 2;
            let currentCenter = { x: relX + radius, y: relY + radius };
            let currentPos = clampToBay(relX, relY, diameter);
            currentCenter = { x: currentPos.x + radius, y: currentPos.y + radius };
            const ITERATIONS = 3; 
            for (let i = 0; i < ITERATIONS; i++) {
                let hasCollided = false;
                loadingBay.querySelectorAll('.tire[data-in-bay="true"]').forEach(otherTire => {
                    if (otherTire.id === currentTire.id) return;
                    const otherRadius = parseFloat(otherTire.dataset.radiusPx);
                    const otherX = parseFloat(otherTire.style.left);
                    const otherY = parseFloat(otherTire.style.top);
                    const otherCenter = { x: otherX + otherRadius, y: otherY + otherRadius };
                    const requiredDistance = radius + otherRadius; 
                    let dx = currentCenter.x - otherCenter.x;
                    let dy = currentCenter.y - otherCenter.y;
                    const actualDistance = Math.sqrt(dx * dx + dy * dy);
                    if (actualDistance < requiredDistance) {
                        const overlap = requiredDistance - actualDistance;
                        hasCollided = true;
                        if (actualDistance < 0.001) {
                            dx = 0.001 * Math.random(); 
                            dy = 0.001 * Math.random();
                            const newDistance = Math.sqrt(dx * dx + dy * dy);
                            const moveX = dx / newDistance * overlap;
                            const moveY = dy / newDistance * overlap;
                            currentCenter.x += moveX;
                            currentCenter.y += moveY;
                        } else {
                            const moveX = dx / actualDistance * overlap;
                            const moveY = dy / actualDistance * overlap;
                            currentCenter.x += moveX;
                            currentCenter.y += moveY;
                        }
                    } 
                });
                currentPos = clampToBay(currentCenter.x - radius, currentCenter.y - radius, diameter);
                currentCenter = { x: currentPos.x + radius, y: currentPos.y + radius };
                if (!hasCollided && i > 0) break;
            }
            return { x: currentPos.x, y: currentPos.y };
        }

        function clampToBay(x, y, diameter) {
            const radius = diameter / 2;
            let centerX = x + radius;
            let centerY = y + radius;
            
            if (centerX < radius) centerX = radius;
            if (centerX > BAY_WIDTH_PX - radius) centerX = BAY_WIDTH_PX - radius;
            if (centerY < radius) centerY = radius;
            if (centerY > BAY_LENGTH_PX - radius) centerY = BAY_LENGTH_PX - radius;
            
            const clampedX = centerX - radius;
            const clampedY = centerY - radius;
            
            return { x: clampedX, y: clampedY };
        }
        
        // レスポンシブ調整
        function adjustResponsive() {
            const loadingBay = document.getElementById('loading-bay');
            const originalScaleFactor = 10;
            const originalBayWidthPx = 2400 / originalScaleFactor; // 元の240px
            const originalBayWidthMm = 2400;

            if (window.innerWidth <= 600) { // スマホ目安
                BAY_WIDTH_PX = 190; // 表示幅縮小
                SCALE_FACTOR = originalBayWidthMm / BAY_WIDTH_PX; // SCALE_FACTORを調整 (例: 2400 / 190 ≈ 12.63)
            } else {
                BAY_WIDTH_PX = originalBayWidthPx; // 元に戻す
                SCALE_FACTOR = originalScaleFactor;
            }

            if (BAY_LENGTH_MM > 0) {
                BAY_LENGTH_PX = BAY_LENGTH_MM / SCALE_FACTOR; // 縦も再計算
                loadingBay.style.height = `${BAY_LENGTH_PX}px`;
                loadingBay.style.width = `${BAY_WIDTH_PX}px`;
                drawGuides(); // ガイド再描画
                // 既存タイヤのサイズを再調整
                document.querySelectorAll('.tire').forEach(tire => {
                    const diameterMM = parseFloat(tire.dataset.diameterMm);
                    const newDiameterPx = diameterMM / SCALE_FACTOR;
                    tire.style.width = `${newDiameterPx}px`;
                    tire.style.height = `${newDiameterPx}px`;
                    tire.dataset.diameterPx = newDiameterPx;
                    tire.dataset.radiusPx = newDiameterPx / 2;
                    adjustTireLabelSizes(tire, newDiameterPx);
                    // 位置クランプ再適用
                    const clampedPos = clampToBay(parseFloat(tire.style.left), parseFloat(tire.style.top), newDiameterPx);
                    tire.style.left = `${clampedPos.x}px`;
                    tire.style.top = `${clampedPos.y}px`;
                });
            }
            updateDistanceInfo();
        }

        // トグルスケール関数
        function toggleScale() {
            const truckContainer = document.querySelector('.truck-container');
            if (isScaledDown) {
                truckContainer.style.transform = 'scale(1)';
                isScaledDown = false;
            } else {
                // 画面高さ計算 (95vh)
                const viewportHeight = window.innerHeight * 0.95; // 95%に変更
                const scaleFactor = viewportHeight / BAY_LENGTH_PX;
                truckContainer.style.transform = `scale(${scaleFactor})`;
                isScaledDown = true;
            }
            updateToggleButtonText();
        }

        function updateToggleButtonText() {
            toggleScaleBtn.textContent = isScaledDown ? '通常表示' : '全体表示';
        }

        // ウィンドウリサイズでレスポンシブ調整
        window.addEventListener('resize', adjustResponsive);

        // --- 初期設定 ---
        initializeContextMenuListeners();
        document.getElementById('startup-dialog').style.display = 'flex';
        updateToggleButtonText();
    </script>
</body>
</html>